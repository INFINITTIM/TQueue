#include <iostream>

#include "TQueue.h"

int main()
{
	TQueue<int> a(5);
	a.push(4);
	std::cout << a << std::endl;
	a.push(5);
	std::cout << a << std::endl;
	a.pop();
	std::cout << a << std::endl;
	a.push(5);
	a.push(5);
	a.push(1);
	std::cout << a << std::endl;
	std::cout << a.front() << std::endl;
	std::cout << a.back() << std::endl;
	a.pop();
	a.pop();
	a.pop();
	std::cout << a << std::endl;
	std::cout << a.front() << std::endl;
	std::cout << a.back();

}

	// первый вариант тестирующей программы

	// P - вероятность добавления
	// Q - вероятность извлечения
	// p < P, то некоторый элемент в очердеь добавляется
	// q < Q, то некоторый элемент из очереди извлекается
	// объявить два счётчика попыток,на добавление и извлечение из очереди
	// два счётчика на то сколько было добавлено сколько было извлечено
	// счетчики попыток положить в полную очередь и извлечь из пустой очереди

	// следующий вариант более сложный

	// написать подобное выше но с визуальным отображением работы очереди на экране
	// P и Q задается с клавиатуры в панельку, задаем максималньый размер очереди в панельку тоже, можно задавать кол-во тактов вот 
	// этой так скажем имитации и основная часть это отрисовать кольцевой буфер на экране чтобы в каждый момент времени отображался фрагмент 
	// заполненной очереди

	//имитация загрузки многопроцессорной вычислительной системы, с некоторым заданным кол-вом вычислительный устройств, 
	// это кол-во мы можем сделать параметров а можем зафиксировать 
	// ... ... ... 
	// ... ... ... 
	// ... ... ...
	// мвс (выше) 
	// в него поступает задача, сложность может быть разная, сложность зхарактеризуется кол-вом тактов необъодимых 
	// для решения задачи и кол-вом необходимых процессоров
	// struct TaskInfo 
	// {
	// int ProcessorCount; 
	// int StepCount;
	// int ID 
	// }
	// (в этой структуре хранить все что было сказано выше (необходимое кол-во вычислительных устройст для решения этой 
	// задачи, необходимое кол-во шагов для того чтобы этаз адача была решена, уникальный ID задачи )
	// struct ProcInfo
	// {
	// bool FREE; (процессор может быть свободен или занят некоторой задачей) 
	// int TaskID; (задача с некоторым ID которая выполняется
	// int StepCountNOW; (какое кол-во шагов уже было сделано на текущий момент) 
	// int  FREETime; (сколько тактов поцессор просто простаивал) 
	// int TaskCount; (сколько уже задач было решено) 
	// }
	// std::vector<ProcInfo> Procs;
	// предполагаем что у нас есть некоторая вероятность поступления задачи в нашу некоторую вычислительную систему
	// P - вероятность поступления задачи 
	// TQueue<TaskInfo> Tasks; 
	// если задача которая находится на выходе не может быть поставлена на решение в устройство то достать ее их очереди и 
	// закинуть в конец (то есть перенааправление в конец очереди наиболее сложных задач) 

	//clrscz();
	//goto xy(x, y);
	//clreof();
